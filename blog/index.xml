<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on Pion</title><link>https://pion.ly/blog/</link><description>Recent content in Blogs on Pion</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 21 Dec 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://pion.ly/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>RACK makes Pion SCTP 71% faster with 27% less latency</title><link>https://pion.ly/blog/sctp-and-rack/</link><pubDate>Sun, 21 Dec 2025 00:00:00 +0000</pubDate><guid>https://pion.ly/blog/sctp-and-rack/</guid><description>&lt;h2 id="what-is-sctp">What is SCTP?&lt;/h2>
&lt;p>SCTP stands for Stream Control Transmission Protocol. At a basic level, SCTP is designed to be reliable, handle de-duplication of packets, and support packets that may be delivered in order or out of order. Beyond transporting messages, SCTP can also set up a connection between users. On a deeper level, SCTP includes native support for multiplexing: multiple applications can take advantage of a single transport connection. SCTP also supports multi-homing, which enables automatic failover from a primary connection to a secondary one.&lt;/p></description></item><item><title>WebRTC Survives When You Walk Out</title><link>https://pion.ly/blog/automatic-renomination/</link><pubDate>Fri, 17 Oct 2025 00:00:00 +0000</pubDate><guid>https://pion.ly/blog/automatic-renomination/</guid><description>&lt;p>Networking for a video call sounds simple. You send your video to the
server and server sends video back. But that mental model breaks down in
the real world. A connection that starts on stable home Wi-Fi may
suddenly need to continue over cellular as someone walks out the door.
The real challenge isn’t just connecting two points! It’s staying
connected as the network beneath you changes.&lt;/p>
&lt;p>With &lt;a href="https://github.com/pion/ice/pull/822">automatic renomination&lt;/a>, Pion
will now handle that completely seamlessly, allowing your media to flow
without skipping a beat. It works by periodically detecting when new
connection candidates are available and automatically switching to the
highest quality candidate, taking advantage of a feature in WebRTC called
&lt;em>renomination&lt;/em>.&lt;/p></description></item><item><title>Making a game with Pion</title><link>https://pion.ly/blog/making-a-game-with-pion/</link><pubDate>Tue, 09 Sep 2025 00:00:00 +0000</pubDate><guid>https://pion.ly/blog/making-a-game-with-pion/</guid><description>&lt;p>(The following was adapted from a talk I gave at &lt;a href="https://dwebseminar.org/weekend/">DWeb Weekend 2025&lt;/a> at the Internet Archive in San Francisco on August 17, 2025)&lt;/p>
&lt;h1 id="simplifying-webrtc-datachannels-for-games">Simplifying WebRTC Datachannels for Games&lt;/h1>
&lt;p>First of all, to get some stuff out of the way, instead of using the &amp;ldquo;super complicated&amp;rdquo; WebRTC datachannels, why don&amp;rsquo;t we use something simpler?&lt;/p>
&lt;h2 id="why-not-use-websockets">Why Not Use Websockets?&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Too slow&lt;/strong>: Most games use UDP with a reliability layer on top.&lt;/li>
&lt;li>&lt;strong>Suitable for turn-based games&lt;/strong>: Fine for games that are turn-based/slow-paced, like Runescape.&lt;/li>
&lt;li>For more details, see:
&lt;ul>
&lt;li>&lt;a href="https://gafferongames.com/post/udp_vs_tcp/">UDP vs TCP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gafferongames.com/post/client_server_connection/">Client-Server Connection&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="the-case-for-web-transport">The Case for Web Transport&lt;/h2>
&lt;ul>
&lt;li>Replacement for Websockets, uses QUIC instead of TCP.&lt;/li>
&lt;li>However, it has been in development for a long time, and I want to get started on making games now.&lt;/li>
&lt;li>Current issues:
&lt;ul>
&lt;li>&lt;a href="https://caniuse.com/webtransport">Caniuse WebTransport&lt;/a>&lt;/li>
&lt;li>Official demos on &lt;a href="https://github.com/w3c/webtransport">GitHub&lt;/a> do not work on Firefox on Windows.&lt;/li>
&lt;li>&lt;a href="https://github.com/w3c/webtransport/issues/675">GitHub Issue&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1969090">Firefox Bugzilla&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Potential&lt;/strong>: Will probably solve most problems once finished and would be the best choice for making a multiplayer game on the web.&lt;/li>
&lt;/ul>
&lt;h2 id="datachannels-a-hidden-gem-of-webrtc">Datachannels: A Hidden Gem of WebRTC&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Feature&lt;/strong>: Lets us send unreliable packets over the web using SCTP.&lt;/li>
&lt;li>Advantage: We don’t need WebTransport; we can use this today.&lt;/li>
&lt;li>They were created in part for exactly this use case
&lt;ul>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc8831#name-use-cases-for-unreliable-da">See the reasoning for unreliable datachannels in the official specification itself&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=13264952">Not to mention that one of the original implementers of WebRTC wanted to enable this usecase&lt;/a>
&lt;img src="https://pion.ly/img/comment_from_webrtc_team.png" alt="Comment from original WebRTC team member">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="benefits-and-drawbacks-of-webrtc">Benefits and Drawbacks of WebRTC&lt;/h2>
&lt;h3 id="benefits">Benefits&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Host flexibility&lt;/strong>: Do not need to host servers - players can make their own.
&lt;ul>
&lt;li>No more need for port forwarding or Hamachi!&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Minimal server requirements&lt;/strong>: Only need one server for signaling.&lt;/li>
&lt;li>&lt;strong>Community-supported specification&lt;/strong>: There are many options for making your own WebRTC-based app.&lt;/li>
&lt;/ul>
&lt;h3 id="drawbacks">Drawbacks&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Complex setup&lt;/strong>: Setting up WebRTC is challenging.&lt;/li>
&lt;li>&lt;strong>Server dependence&lt;/strong>: You need to host or use two different servers (Signaling + STUN/TURN).
&lt;ul>
&lt;li>Can use Google’s STUN, but combining signaling and STUN into one server would be nice.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="webrtc-implementations">WebRTC Implementations&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/webrtc-sdk/libwebrtc?tab=readme-ov-file">libwebrtc&lt;/a> - (a fork of) the original WebRTC implementation.&lt;/li>
&lt;li>&lt;a href="https://github.com/paullouisageneau/libdatachannel">libdatachannel&lt;/a> - C/C++.&lt;/li>
&lt;li>&lt;a href="https://github.com/pion/webrtc">Pion WebRTC&lt;/a> - Go.&lt;/li>
&lt;li>&lt;a href="https://github.com/webrtc-rs/webrtc">webrtc-rs&lt;/a> - Rust (using Tokio Runtime).&lt;/li>
&lt;li>&lt;a href="https://github.com/algesten/str0m">str0m&lt;/a> - Rust (sans-io).&lt;/li>
&lt;li>&lt;a href="https://github.com/sipsorcery-org/sipsorcery">sipsorcery&lt;/a> - C#&lt;/li>
&lt;li>&lt;a href="https://github.com/ValveSoftware/GameNetworkingSockets">GameNetworkingSockets&lt;/a>
&lt;ul>
&lt;li>Uses ICE and STUN/TURN for Peer to Peer.&lt;/li>
&lt;li>Created by Valve and made for Steam, which means if you&amp;rsquo;ve ever played a game like Counter Strike or Deadlock, you&amp;rsquo;ve already seen this library in action!&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="existing-game-networking-libraries-using-webrtc">Existing Game Networking Libraries Using WebRTC&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/geckosio/geckos.io">Geckos.io&lt;/a>
&lt;ul>
&lt;li>A client-server abstraction for WebRTC Datachannels written in Node.js.&lt;/li>
&lt;li>Past experience: Really nice but a bit inefficient. See &lt;a href="https://github.com/geckosio/geckos.io/issues/269">GitHub Issue&lt;/a>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/poki/netlib">Netlib&lt;/a> - Peer-to-peer WebRTC datachannel library for TypeScript.&lt;/li>
&lt;li>&lt;a href="https://github.com/johanhelsing/matchbox">Matchbox&lt;/a> - WebRTC datachannel library for Rust, compiles to both native and WASM.&lt;/li>
&lt;li>&lt;a href="https://github.com/peers/peerjs">PeerJS&lt;/a> - Great for browser-only apps/games, not specifically for game networking.&lt;/li>
&lt;li>&lt;a href="https://github.com/rameshvarun/netplayjs">Netplayjs&lt;/a> - Untested but seems to work well.&lt;/li>
&lt;li>&lt;a href="https://github.com/godotengine/webrtc-native">Godot Engine&amp;rsquo;s WebRTC Native&lt;/a> - Official Godot bindings to libdatachannel for Godot’s multiplayer API.&lt;/li>
&lt;/ul>
&lt;h2 id="real-world-uses">Real-World Uses&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>WebXash3D&lt;/strong>: Reimplementation of Half-Life 1 + Counter-Strike 1.6 using WebRTC.
&lt;ul>
&lt;li>&lt;a href="https://github.com/yohimik/webxash3d-fwgs">GitHub WebXash3D&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/ololoken/xash3d-launcher">Xash3D Launcher&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://turch.in/cs/index.html">Counter Strike 1.6 on the web&lt;/a>&lt;/li>
&lt;li>&lt;img src="https://pion.ly/img/counter_strike_on_the_web.png" alt="Counter Strike">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Hypersomnia&lt;/strong> - Open source 2D shooter made with C++ and libdatachannel
&lt;ul>
&lt;li>Has cross platform capabilities between both
&lt;ul>
&lt;li>The &lt;a href="https://store.steampowered.com/app/2660970/Hypersomnia/">native Steam port&lt;/a>&lt;/li>
&lt;li>And in the browser (On &lt;a href="https://www.crazygames.com/game/hypersomnia">CrazyGames&lt;/a> and &lt;a href="https://hypersomnia.io/">the official website&lt;/a>)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/TeamHypersomnia/Hypersomnia">Github Link&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="why-go-for-development">Why Go for Development?&lt;/h2>
&lt;ul>
&lt;li>Efficient: It just gets the job done.&lt;/li>
&lt;li>Pion: Has a pure-Go implementation of WebRTC.&lt;/li>
&lt;li>Minimal dependencies: No need for external dependencies like OpenSSL.&lt;/li>
&lt;/ul>
&lt;h2 id="why-not-rust">Why Not Rust?&lt;/h2>
&lt;ul>
&lt;li>Preference: I like Rust, but Go has a more active scene/easier help for WebRTC.&lt;/li>
&lt;li>Speed of development: It&amp;rsquo;s faster to code in Go compared to Rust.&lt;/li>
&lt;/ul>
&lt;h2 id="why-ebitengine-for-game-development">Why Ebitengine for Game Development?&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://ebitengine.org/">Website Link&lt;/a>&lt;/li>
&lt;li>&lt;strong>Versatile&lt;/strong>: 2D game engine that works across various platforms.
&lt;ul>
&lt;li>The creator, &lt;a href="https://hajimehoshi.com/">Hajime Hoshi&lt;/a>, has ported the engine (and the Go language!) to &lt;a href="https://ebitengine.org/en/blog/native_compiling_for_nintendo_switch.html">the Nintendo Switch&lt;/a> and other game consoles&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Battle Tested&lt;/strong>: Has been used for actual games like
&lt;ul>
&lt;li>&lt;a href="https://playism.com/en/game/frommadness-withlove/">From Madness with Love&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://store.steampowered.com/app/2101130/From_Madness_with_Love/">Steam Link&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Coral &amp;amp; The Abyss
&lt;ul>
&lt;li>&lt;a href="https://store.steampowered.com/app/3123920/Coral__The_Abyss/">Steam Link&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.nintendo.com/us/store/products/coral-and-the-abyss-switch/">Nintendo eShop Link&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Rakuen
&lt;ul>
&lt;li>&lt;a href="https://store.steampowered.com/app/559210/Rakuen/">Steam Link&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.nintendo.com/us/store/products/rakuen-deluxe-edition-switch/">Nintendo eShop Link&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>And more on the &lt;a href="https://ebitengine.org/en/showcase.html">Ebitengine Showcase Page&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Potential Crossplay&lt;/strong>: You could make a cross platform multiplayer game in pure Go that works between the Nintendo Switch, PC, and the browser!&lt;/li>
&lt;/ul>
&lt;h2 id="official-pion-example">Official Pion Example&lt;/h2>
&lt;ul>
&lt;li>We now have an official example using Ebitengine in the Pion &lt;a href="https://github.com/pion/example-webrtc-applications">example-webrtc-applications&lt;/a> repository&lt;/li>
&lt;li>This includes an bundled in signaling server so you can host your own lobby, and connect with another player.&lt;/li>
&lt;li>&lt;a href="https://github.com/pion/example-webrtc-applications/tree/master/ebiten-game">&lt;strong>Github Link to Game&lt;/strong>&lt;/a>&lt;/li>
&lt;li>&lt;strong>PR where it was merged in&lt;/strong>: &lt;a href="https://github.com/pion/example-webrtc-applications/pull/351">Example WebRTC Applications&lt;/a>&lt;/li>
&lt;li>&lt;strong>Limitations&lt;/strong>
&lt;ul>
&lt;li>Right now, this can only support two players on the same computer
&lt;ul>
&lt;li>Could probably work between two different computers, but we would need to figure out how to setup CORS properly for the signaling server&lt;/li>
&lt;li>The machinery is there to support more than two players in a lobby, but as of writing this article it is &lt;a href="https://github.com/pion/example-webrtc-applications/blob/5c7005933879d34fa19b4d0c744bb884a247f5dc/ebiten-game/game/main.go#L154">currently hardcoded&lt;/a> to just two
&lt;img src="https://pion.ly/img/game_on_web_and_desktop.png" alt="Picture of game">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="other-games-that-use-webrtc">Other Games That Use WebRTC&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://toughlovearena.com/">Tough Love Arena&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.counterpicklabs.com/">Counterpick Labs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://2dsoccer.com/">2D Soccer&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="possibilities-with-webrtc">Possibilities with WebRTC&lt;/h2>
&lt;ul>
&lt;li>Hosting a Minecraft-style game without dedicated servers or port forwarding.&lt;/li>
&lt;li>Players host everything themselves: no need for VPN/Hamachi.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="community-acknowledgements">Community Acknowledgements&lt;/h2>
&lt;ul>
&lt;li>A big thanks to:
&lt;ul>
&lt;li>&lt;a href="https://pion.ly/discord">The Pion Discord&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://discord.gg/jXAP8jp3Nn">The libdatachannel Discord&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://discord.gg/3tVdM5H8cC">The Ebitengine Discord&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://discord.com/invite/game-development-in-rust-676678179678715904">The Rust gamedev Discord&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>And many more who made this journey possible. I stand on the shoulders of giants.&lt;/li>
&lt;/ul></description></item><item><title>FEC with Pion</title><link>https://pion.ly/blog/fec-with-pion/</link><pubDate>Mon, 23 Jun 2025 00:00:00 +0000</pubDate><guid>https://pion.ly/blog/fec-with-pion/</guid><description>&lt;p>We are excited to have FEC encoding support available in the pion/webrtc v4.1.2 + pion/interceptor v0.1.38. In this blog post, we&amp;rsquo;ll explain what FEC is and how to implement it with Pion.&lt;/p>
&lt;blockquote>
&lt;p>If you already know FEC, feel free to skip to &lt;a href="https://pion.ly/blog/fec-with-pion/#flexfec-in-pion">FlexFEC in Pion&lt;/a>.&lt;/p>&lt;/blockquote>
&lt;h2 id="quick-background-what-is-fec">Quick background: What is FEC?&lt;/h2>
&lt;p>Forward Error Correction (FEC) is a proactive loss-recovery mechanism:&lt;/p>
&lt;p>The sender transmits extra mathematically derived parity packets (e.g. xor of the media packets) along with each block of media packets. If the receiver later discovers that one or even more packets are lost, it can use the parity packets to recover the lost packets, using the XOR result of the received packets and the parity (repair) packet, all without waiting for the lost packets to be retransmitted.&lt;/p></description></item><item><title>Pion Opus</title><link>https://pion.ly/blog/pion-opus/</link><pubDate>Sun, 02 Oct 2022 00:00:00 +0000</pubDate><guid>https://pion.ly/blog/pion-opus/</guid><description>&lt;p>I am so excited to announce that &lt;a href="https://github.com/pion/opus">pion/opus&lt;/a> is now available. It is a Pure Go implementation
of the &lt;a href="https://opus-codec.org/">Opus Codec&lt;/a>. pion/opus is far from done though. It is far enough along for others to start playing
with and contributing too though. We still have a lot more work to do. If you are interested now is a great time to get involved!&lt;/p>
&lt;p>Now that the code is shared I wanted to share my goals, what I learned and hopes for the future.&lt;/p></description></item><item><title>ION, grown up and moving out.</title><link>https://pion.ly/blog/ion-grown-up-and-moving-out/</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>https://pion.ly/blog/ion-grown-up-and-moving-out/</guid><description>&lt;p>Going forward the ION project will now be hosted at &lt;a href="https://github.com/ionorg/ion">ionorg/ion&lt;/a>. ION itself is not changing in any other way.
We are just making these changes to more clearly reflect the actual leadership and organization of the project. Changes like this aren&amp;rsquo;t free
though. Users may have to change imports, tooling and other software. We apologize for that, but hope these benefits are worth it.&lt;/p>
&lt;h3 id="recognize-the-actual-leadership-of-ion">Recognize the actual leadership of ION&lt;/h3>
&lt;p>The leadership and contributors of ION and Pion are often conflated. Often I will have users ask me questions or even thank me for ION.
This confusion is demotivating for the people actually doing the hard work. I worry that long term it will hurt the project.&lt;/p></description></item><item><title>Pion is a nonprofit project</title><link>https://pion.ly/blog/pion-nonprofit/</link><pubDate>Mon, 27 Dec 2021 00:00:00 +0000</pubDate><guid>https://pion.ly/blog/pion-nonprofit/</guid><description>&lt;p>Pion saw its first commit Wed Mar 7 2018. I didn&amp;rsquo;t have grand aspirations
for the project. It &lt;a href="../why-webrtc">felt important&lt;/a> at the time to make WebRTC more
accessible. Proprietary alternatives were being proposed and they
didn&amp;rsquo;t have technical advantages, they were just easier to use.
I enjoyed solving issues one at a time and helping users
use Pion.&lt;/p>
&lt;p>Interest in WebRTC then exploded in 2020. Lots of new demand for WebRTC
software popped up over night. New developers started learning it,
companies were founded around it and lots of VC money started entering
the space.&lt;/p></description></item><item><title>Why WebRTC?</title><link>https://pion.ly/blog/why-webrtc/</link><pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate><guid>https://pion.ly/blog/why-webrtc/</guid><description>&lt;p>This is a question I get in lots of different forms. Why should I use WebRTC instead of my
preferred video protocol? Why does WebRTC need to be in my browser? Why does WebRTC have to
be so complicated? Why do you continue to work on WebRTC projects?&lt;/p>
&lt;p>These are my answers to the Why&amp;rsquo;s of WebRTC. Lots of nuance exists, and these answers are heavily
influenced by the work I do. I have been working with WebRTC since 2013. In that time I worked on two implementations &lt;a href="https://github.com/pion/webrtc">Pion&lt;/a>
and &lt;a href="https://github.com/awslabs/amazon-kinesis-video-streams-webrtc-sdk-c">KVS WebRTC&lt;/a>. I also co-authored a book &lt;a href="https://webrtcforthecurious.com/">WebRTC for the Curious&lt;/a>.
I have used WebRTC at &lt;a href="https://golightstream.com/">startups&lt;/a> and &lt;a href="https://9to5mac.com/2021/06/11/hands-on-heres-a-first-look-at-how-facetime-works-in-a-web-browser/">corporate&lt;/a> projects.&lt;/p></description></item></channel></rss>