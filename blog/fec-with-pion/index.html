<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>FEC with Pion | Pion</title><meta name=description content="How to use FEC in Pion"><link rel="shortcut icon" type=image/png href=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAC+lBMVEUAAADmOTblOTXmOjXlOjbmOjblOzXlOzbnOjbmOzbkOTTnOzjnOzfkODTnOTbvPjzpPDflOTbrQD/kODXsQDblODXmOzfmOjfWJiTiNzPmOTXfNjDvREHfMy7uQT7zRUToPjnlOjXcMy/iNjLnOjjgNTHqOzjeMzDpOjnlODPmPzroOzfjNzTjODTjODPjNTHpOzfsPzrmOjblOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXmOjblOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXmOzblOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOjblOTXlOTXmOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOjXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOjbmOTXlOTXlOTXmOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXmOTXlOTXlOTXlOTXlOTXlOTXlOTXmOjblOTXlOTXmOTblOjXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXmOjblOTXmOTblOTXlOTXlOTXmOTXnOzfmOjblOTXmOjblOTXlOTXlOjblOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXnOzflOTXmOjblOTXlOTXlOTXlOTXlOTXlOTXlOTXmOTbmOjXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXlOTXmOjblOTXlOTXlOTXmPDflOTX///+vM0BfAAAA/HRSTlMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEdW5zM5/TVKAcsG4TT+PlKWuXRgSYBEXTf/erI+k1i3XIPJ7D798BsLgr+TAlew60lM8vODlgQYdTHKqAfJKn8xSMTtI0NEZmnDXudDBKqaS3hHhk0CCJQGCCJwvBWo7tmvg6/U7cWFcoCiosIEH3xR+sw47UX2iE7g8Zq9ldd1+IEmgm97q8IAQPtBbPcCLyyYPNAbdaWL7FzCis88oa2fklwMnnbFIWe2JRv3gKuC83SdayXZKQDATZn2VF2pg7Q72sNBs+MTgFx1Y14AAAAAWJLR0T9SwmT6QAAAAd0SU1FB+MCDxQvITv9oyUAAANQSURBVDjLbZN5WJRVFMbv98JNhprSCixsUdsstWVEcgxjxkTCBsaFYWbED03DmITBBtAapVSgQiwTTR2pVCqh0txwQXNrQyxaLbXNbLHNbN/fP7rffI3a83T++e7znd9zzj3nvq8Q/4ZmG5A6MO36QfbBuCF9iC1O/DfibYNvzHBQhXMobhqWOTzrZnlK+jRkj7iFdOXkptE9EqOc5OgxeegSy0t48r30+ccWjEvV3YUYP+FWJ70TJyHBzFtwWxE5OfX2xNNRbABnWAN3TCFLCmAx8meiNI3eYBk0IUxA1bROvTPE8gqcpQBUTqN3+l0w4BgguuLusIszZqpzt7OrXLzn3mj+JKCOs2bTPeccKVBdw6JanGtJuu/+B0ygbm49krvDY6d9HsR5D9JXDCmR/tD8h6PA+QvYkAVNJi30cgREmZ2LHkkRGLKYviVmheE6l0YgsKyR5ZUi1cexSJCPPsbQ48tNYMVAXV/ZQ5OoYtMTIswnn1J06So2Z8ME0OLn08+on882cbVYw7RsdMdzXFuIeBOwYJ3btR4XoH4Dp4mNzG/V5IWbOKUFsTFRO5rTrVLbvIUZYiuDF0nZ2saGbSkxIGVmCRdsl/L5iawROxi8WMqdu7h4XPyJCnlFDPaUvRSwUdSwrTUK7C4zW4xUH88wrkZy/J4XaBflbAxA7nyR3pcgUeh8+RVYktp1h8HV7+VS0cGcfZCtr6oHrwDyXpvTCby+l43LFPDGm3xLFPvYroB8pba3sxLVk8ve1X46RqntJ77Dpv1iQAb9ASjAF6L93epI/XsHDtLV0Wl0mMzyQ+KS9+mcADVm2wdOpcoNH+7Q6ftoFpRoPnZxjLHkw8yc+skRhj9d+FlU177c9ZshLsW+3fy8VoGXfRHijENHGbZeHilc+WVH1f7KK6Tog5ZmOr5KUuJH4AhDmxoYvrLbSSNchcjXOoOdhrr6YlIJvQ6G+8UJ7RtP3be9hEjpX7pL56JaRA2WgII1qnX4ak3g2GF7OpKvqfzuOOn3mLI3jFMx280Oa1x01d8Hjv2Q66b7x3kx4whxLX5qb56rjKEA18+Zv+jUj//6G647xZ3S9rvNuPCSkDHooKIDdQma+J9A6R85B7f8+Vfk7xPe/gdCN2wvY+TSJAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wMi0xNVQyMDo0NzozMyswMTowMOnp2+YAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDItMTVUMjA6NDc6MzMrMDE6MDCYtGNaAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC><link href="https://fonts.googleapis.com/css?family=Quicksand" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css><link href=/css/main.css rel=stylesheet><script async defer src=https://buttons.github.io/buttons.js></script><script defer src=https://use.fontawesome.com/releases/v6.7.2/js/all.js></script><script src=/js/bulma-menu.js></script><script src=/js/knowledge-base-sidebar.js></script><script src=/js/triage.js></script><script src=/js/tinybind.js></script></head><body><nav class="navbar is-black" role=navigation aria-label="main navigation"><div class=navbar-brand><a class=navbar-item href=/><img src=/img/pion-logo.svg width=112 height=28>
</a><a class="navbar-item is-hidden-desktop" href=https://github.com/pion target=_blank><span class=icon><i class="fab fa-github"></i>
</span></a><a class="navbar-item is-hidden-desktop" href=https://x.com/_pion target=_blank><span class=icon><i class="fab fa-x-twitter"></i>
</span></a><a class="navbar-item is-hidden-desktop" href=https://bsky.app/profile/pion.ly target=_blank><span class=icon><i class="fab fa-bluesky"></i>
</span></a><a class="navbar-item is-hidden-desktop" href=https://discord.gg/6EsQz85vPE target=_blank><span class=icon><i class="fab fa-discord"></i>
</span></a><a role=button class="navbar-burger burger" aria-label=menu aria-expanded=false data-target=navbarMenuItems><span aria-hidden=true></span>
<span aria-hidden=true></span>
<span aria-hidden=true></span></a></div><div id=navbarMenuItems class=navbar-menu><div class=navbar-start><a class=navbar-item href=/blog/>Blog
</a><a class=navbar-item href=/why-pion/>Why Pion
</a><a class=navbar-item href=https://github.com/pion/awesome-pion>awesome-pion
</a><a class=navbar-item href=https://webrtcforthecurious.com>WebRTC for the Curious
</a><a class=navbar-item href=https://siobud.com/meeting>Office Hours
</a><a class=navbar-item href=/triage/>Triage</a></div><div class=navbar-end><div class=navbar-item><div class="buttons is-hidden-touch"><a class="navbar-item navbar-item-desktop" href=https://github.com/pion target=_blank><span class=icon><i class="fab fa-github"></i>
</span></a><a class="navbar-item navbar-item-desktop" href=https://x.com/_pion target=_blank><span class=icon><i class="fab fa-x-twitter"></i>
</span></a><a class="navbar-item navbar-item-desktop" href=https://bsky.app/profile/pion.ly target=_blank><span class=icon><i class="fab fa-bluesky"></i>
</span></a><a class="navbar-item navbar-item-desktop" href=https://discord.gg/6EsQz85vPE target=_blank><span class=icon><i class="fab fa-discord"></i></span></a></div></div></div></div></nav><main><section><div class="columns has-text-centered" style=padding-top:3em><div class=column><h1 class=title style=font-size:3rem>FEC with Pion</h1><p>How to use FEC in Pion</p><p>Jingyang Kang, Aleksandr Alekseev, Joe Turki -- 2025-06-23</p><hr class=pion-hr></div></div></section><section><div class=content style=padding:3em><p>We are excited to have FEC encoding support available in the pion/webrtc v4.1.2 + pion/interceptor v0.1.38. In this blog post, we&rsquo;ll explain what FEC is and how to implement it with Pion.</p><blockquote><p>If you already know FEC, feel free to skip to <a href=/blog/fec-with-pion/#flexfec-in-pion>FlexFEC in Pion</a>.</p></blockquote><h2 id=quick-background-what-is-fec>Quick background: What is FEC?<a class=content-header-href href=#quick-background-what-is-fec><i class="fas fa-paperclip"></i></a></h2><p>Forward Error Correction (FEC) is a proactive loss-recovery mechanism:</p><p>The sender transmits extra mathematically derived parity packets (e.g. xor of the media packets) along with each block of media packets. If the receiver later discovers that one or even more packets are lost, it can use the parity packets to recover the lost packets, using the XOR result of the received packets and the parity (repair) packet, all without waiting for the lost packets to be retransmitted.</p><p>A simple example:</p><table><thead><tr><th>Data packets</th><th>Parity packet</th><th>Recovery logic</th></tr></thead><tbody><tr><td><code>A</code> <code>B</code> <code>C</code></td><td><code>P = A ⊕ B ⊕ C</code></td><td>If <code>B</code> is lost, receiver computes <code>B = A ⊕ C ⊕ P</code></td></tr></tbody></table><p>Because parity travels with the media, recovery happens locally and immediately. The trade‑off is more data on the link.</p><h2 id=we-already-have-nack-why-fec>We Already Have NACK, Why FEC?<a class=content-header-href href=#we-already-have-nack-why-fec><i class="fas fa-paperclip"></i></a></h2><p>Alice is sending a video stream to Bob with WebRTC. In an imaginary perfect network condition in which no packet loss happens and the network delay is 0 ms, all Alice needs to do is encode the video, pack RTP packets, and send them to Bob. What Bob needs to do is simply depacketize RTP packets and decode the payload into video frames. Everything is great except this imaginary perfect network condition doesn&rsquo;t exist.</p><pre class=mermaid>
  sequenceDiagram
    title &#34;Perfect Network&#34;
    participant Alice
    participant Bob
    Alice-&gt;&gt;Bob: Video Packet n
    Alice-&gt;&gt;Bob: Video Packet n+1
    Alice-&gt;&gt;Bob: Video Packet n+2
    Note right of Bob: Great! :)&lt;br/&gt;But not reality
</pre><p>Let&rsquo;s gradually introduce more factors into our network, to make it closer and closer to the real internet we live in. First, let&rsquo;s add packet loss while keep network delay still at 0 ms. With packet loss, not every packet Alice sends is guaranteed to be received by Bob. So, we need a mechanism to recover these lost packets. A straight forward approach is to make Alice resend the lost packets again. In order to notify Alice which packet is lost and needs to be retransmitted, Bob should explicitly send message to Alice, containing the sequence number of lost packets. This is NACK. With NACK in our lossy but no-delay network, all packets can be retransmitted immediately after Bob sends a NACK request. Problem solved? In this case, yes. But in the real world, no.</p><pre class=mermaid>
  sequenceDiagram
    title Using NACK
    participant Alice
    participant Bob
    Alice-&gt;&gt;Bob: Video Packet n
    Alice-&gt;&gt;Bob: Video Packet n+1
    Alice-&gt;&gt;Bob: Video Packet n+2
    alt Packet n lost
        Bob--&gt;&gt;Alice: NACK n
        Note right of Bob: Extra RTT(s) here
        Alice-&gt;&gt;Bob: RTX Packet n
    end
</pre><p>Next, we are also adding delays to our imaginary network. At this point, it basically has all the characteristics of real world networks. Can our current mechanism tackle network delay + loss without hurting transportation quality? Sadly, no. If Alice packs a frame into 10 packets, Bob can&rsquo;t decode the frame even if only 1 packet is lost. And since NACK takes at least 1 additional RTT (more than 1 when retransmitted packets are lost too), this frame is delayed on Bob&rsquo;s side. To make things even worse, in modern video codecs, in order to increase compression ratio, encoders use a technology called <strong>forward prediction</strong>, which means subsequent frames relies on the data of previous frame to decode. For any frame delayed due to network loss, all subsequent dependent frames will be delayed. This can cause noticeable jank for Bob, which is bad.</p><pre class=mermaid>
  sequenceDiagram
    title Using FEC
    participant Alice
    participant Bob
    Alice-&gt;&gt;Bob: Video Packet n
    Alice-&gt;&gt;Bob: Video Packet n+1
    Alice-&gt;&gt;Bob: Video Packet n+2
    Alice-&gt;&gt;Bob: FEC Packet
    alt Packet n lost
        Bob-&gt;&gt;Bob: Recover n from n+1, n+2, and the FEC Packet
        Note right of Bob: No extra RTT(s) here
    end
</pre><p>FEC is a mechanism that can mitigate this. FEC stands for <strong>Forward Error Correction</strong>. Basically, it means that we can send more data to recover from potential packet losses. With FEC enabled, Alice does not only send 10 video packets to Bob, but also a few redundant packets, containing data XORed from video packets. When packets get lost during transmission, Bob can try to recover it with redundant data from FEC packets. In this case, no additional RTT is needed to recover packets lost, so video streaming is not affected.</p><h2 id=recovery-groups>Recovery groups<a class=content-header-href href=#recovery-groups><i class="fas fa-paperclip"></i></a></h2><h3 id=on-the-sender-side>On the sender side<a class=content-header-href href=#on-the-sender-side><i class="fas fa-paperclip"></i></a></h3><p>Media packets are grouped for protection, for example:</p><ul><li>Group 1: M1, M3, M5 protected by F1</li><li>Group 2: M2, M4 protected by F2</li></ul><p><img src=/img/fec_sender.drawio.png alt="FEC Sender"></p><h3 id=on-the-receiver-side>On the receiver side<a class=content-header-href href=#on-the-receiver-side><i class="fas fa-paperclip"></i></a></h3><p>During the transmission, some media packets might be lost:</p><p>Received FEC packets are used to reconstruct missing data:</p><ul><li>F1 recover any lost packet from Group 1</li><li>F2 recover any lost packet from Group 2</li></ul><p><img src=/img/fec_receiver.drawio.png alt="FEC Receiver"></p><h2 id=fec-mechanisms-in-webrtc>FEC Mechanisms in WebRTC<a class=content-header-href href=#fec-mechanisms-in-webrtc><i class="fas fa-paperclip"></i></a></h2><p>In WebRTC there are two main RTP based forward-error-correction (FEC) mechanisms. They both generate XOR parity packets, but the way they&rsquo;re signalled and routed is very different:</p><table><thead><tr><th>Feature</th><th><strong>FlexFEC (<a href=https://datatracker.ietf.org/doc/rfc8627/>RFC 8627</a>)</strong></th><th><strong>ULPFEC + RED (<a href=https://datatracker.ietf.org/doc/rfc5109/>RFC 5109</a>)</strong></th></tr></thead><tbody><tr><td><strong>Transport</strong></td><td>Travels on its own SSRC and payload-type, SDP advertises an extra repair m-section and an <code>a=ssrc-group:FEC-FR &lt;media-ssrc> &lt;fec-ssrc></code> line.</td><td>Parity bytes are wrapped inside a RED packet that uses the same SSRC as the media. No extra m-section needed; you just add a RED and a ULPFEC payload-type.</td></tr><tr><td><strong>Codecs</strong></td><td>True <strong>Codec-agnostic</strong>, works with VP8/9, H.264, AV1 … anything that produces RTP packets.</td><td>While <strong>codec-agnostic</strong> in theory, Chromium limits full protection to VPx and AV1. With H264 and H265 the encoder can&rsquo;t flag per-partition loss importance in a way that is useful for FEC. ULPFEC + Nack for codecs without Picture-ID will have to retransmit FEC packets, So ULPFEC is not used for H264 and H265.</td></tr><tr><td><strong>Loss patterns handled</strong></td><td>Two-dimensional (rows × columns) parity</td><td>Single-direction parity</td></tr><tr><td><strong>Implementation status</strong></td><td>All Chromium-based browsers can <em>receive</em> FlexFEC; <strong>send-side</strong> support is still immature. Limited receive support in Safari and Firefox doesn&rsquo;t support it.</td><td><strong>Send + Receive</strong> in Chrome, Firefox, Safari.</td></tr></tbody></table><p>FlexFEC is the only option that remains fully codec-agnostic. ULPFEC does a fine job for VP8/VP9/AV1, but offers little benefit for H264 or H265.</p><h3 id=codec-integrated-fec>Codec-integrated FEC<a class=content-header-href href=#codec-integrated-fec><i class="fas fa-paperclip"></i></a></h3><p>While FlexFEC and ULPFEC live at the RTP packet layer, some codecs integrate redundancy straight into the encoded payload itself.</p><p>The only such codec you&rsquo;ll meet in browsers today is Opus, and the way it works is when you set <code>useinbandfec=1</code>, the Opus encoder embeds a low-bit-rate redundancy (LBRR) copy of frame N-1 inside the packet that carries frame N. If packet N-1 is lost, the decoder can reconstruct it from the tail of N.</p><h2 id=fec-isnt-magic-trade-offs-to-keep-in-mind>FEC isn&rsquo;t magic: trade-offs to keep in mind<a class=content-header-href href=#fec-isnt-magic-trade-offs-to-keep-in-mind><i class="fas fa-paperclip"></i></a></h2><ol><li><p><strong>Bandwidth overhead</strong>
If you add 20% FEC without raising the send cap, you&rsquo;ll need to reduce the video resolution or quality to stay within the cap. In good network conditions where the packet loss is minimal, FEC steals bandwidth in exchange for redundancy you don&rsquo;t need.</p></li><li><p><strong>Extra load on a congested link</strong>
When the loss is caused by congestion, adding more packets for FEC can deepen the problem, in congested networks, sometimes disabling FEC yields better results.</p></li><li><p><strong>Loss pattern mismatch</strong>
Random 1-2% loss is where light FEC shines. But for example, 10% bursts every few hundred ms requires high parity, which often ends up worse than just using RTX.</p></li><li><p><strong>Silent failures</strong>
Analytics may count frames as &ldquo;recovered&rdquo; even if the end user gets artifacts or glitches.</p></li><li><p><strong>Only packets, not outages</strong>
A 100ms network stall drops all packets, media and parity alike; so buffering or retransmission is still needed.</p></li><li><p><strong>FEC is best for high-latency networks</strong>
FEC is designed to avoid the delay of waiting for retransmissions, but for example, if your round-trip time (RTT) is under 30-50ms, do you really need it? In low-latency networks, simply retransmitting lost packets might be more efficient and better overall than sending redundant data up front.</p></li></ol><p>So, start with the lowest cost protection first (Opus in-band FEC for audio, RTX for video). Add FEC only when telemetry shows sustained loss or when you have bandwidth room. FEC should be a dynamic option, not a set-and-forget checkbox that you enable for all users, and all network conditions.</p><h2 id=fec-algorithms-beyond-xor>FEC algorithms beyond XOR<a class=content-header-href href=#fec-algorithms-beyond-xor><i class="fas fa-paperclip"></i></a></h2><p>FlexFEC and ULPFEC both use XOR-based recovery logic to generate packets. Another family of algorithms, like <a href=https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction>Reed-Solomon</a>, can recover from more complex losses but are currently not standardized in WebRTC due to their higher computational cost and block-based design, which is not best suited for real-time use in WebRTC.</p><p>If you&rsquo;re curious, the <a href=https://github.com/klauspost/reedsolomon>klauspost/reedsolomon Go library</a> offers a SIMD-accelerated implementation that&rsquo;s fun to experiment with.</p><h2 id=flexfec-in-pion>FlexFEC in Pion<a class=content-header-href href=#flexfec-in-pion><i class="fas fa-paperclip"></i></a></h2><p>Pion now supports basic FlexFEC encoding! You can pair it with Chromium and Safari (receive-only), and it&rsquo;s simple to integrate – just register the payload type in your media engine and add the interceptor, then you&rsquo;re good to go! More about it in <a href=/blog/fec-with-pion/#enable-flexfec-encoding-in-pion>Enable FlexFEC Encoding in Pion</a>.</p><p>For a quick demo, you can check out the <a href=https://github.com/pion/webrtc/tree/887f5c6e0c405ac51b5a1b7db1e23dc4f9c7e4fb/examples/play-from-disk-fec>play-from-disk-fec</a> example.</p><h3 id=what-to-look-forward-to-in-the-final-flexfec-implementation>What to look forward to in the final FlexFEC implementation<a class=content-header-href href=#what-to-look-forward-to-in-the-final-flexfec-implementation><i class="fas fa-paperclip"></i></a></h3><p>If you worked with FlexFEC, you may have come across multiple draft versions, <strong>FlexFEC-03</strong> and <strong>FlexFEC-20</strong>. The final standard is published as <a href=https://datatracker.ietf.org/doc/rfc8627/>RFC 8627</a>, and while it builds on ideas introduced in the -20 draft, it formalizes several features and adds important clarifications.</p><p>Although Pion doesn&rsquo;t yet fully support RFC 8627, we&rsquo;re tracking it closely and excited about the improvements it will bring, here are some of the highlights:</p><ol><li><p><strong>Flexible Masking (Selective Protection)</strong>:
RFC 8627 introduces a <strong>flexible mask</strong> mode, allowing senders to protect an arbitrary subset of source packets. Instead of a fixed pattern, it sends a bitmask indicating exactly which packets are covered. This can be used to implement smarter FEC strategies, such as protecting only keyframes or higher-priority codec configuration packets.
-> <a href=https://datatracker.ietf.org/doc/rfc8627/#section-1.1.4>RFC 8627, Section 1.1.4</a></p></li><li><p><strong>Hybrid FEC and Retransmission Support</strong>
The final spec explicitly supports both <strong>proactive FEC</strong> and <strong>RTP retransmission</strong>. It also requires that when FlexFEC is used alongside another retransmission mechanism, the answer in an SDP negotiation must use FlexFEC only, ensuring consistent protection handling.
-> <a href=https://datatracker.ietf.org/doc/rfc8627/#section-1.1.7>RFC 8627, Section 1.1.7</a></p></li><li><p><strong>Improved Scalability and Consistency</strong>
RFC 8627 addresses scalability limitations from earlier FEC mechanisms like <a href=https://datatracker.ietf.org/doc/html/rfc5109>RFC 5109</a> and <a href=https://datatracker.ietf.org/doc/html/rfc2733>RFC 2733</a>. It also reuses the <strong>RTP repair stream format</strong> defined in <a href=https://datatracker.ietf.org/doc/html/rfc6363>RFC 6363</a>, making it more consistent with modern RTP practices and easier to interoperate with existing tooling.
-> <a href=https://datatracker.ietf.org/doc/rfc8627/#section-1.1.1>RFC 8627, Section 1.1.1</a></p></li><li><p><strong>Packet and Header Format Clarifications</strong>
The final spec clearly defines key header fields. For example, the <strong>R bit</strong> distinguishes retransmission (R=1) from FEC repair (R=0), while the <strong>F bit</strong> selects between flexible-mask mode (F=0) and fixed-offset mode (F=1). These explicit semantics simplify implementation logic and parsing.
-> <a href=https://datatracker.ietf.org/doc/rfc8627/#section-6.2>RFC 8627, Section 6.2</a></p></li></ol><h3 id=enable-flexfec-encoding-in-pion>Enable FlexFEC Encoding in Pion<a class=content-header-href href=#enable-flexfec-encoding-in-pion><i class="fas fa-paperclip"></i></a></h3><p>You can use the helper for quick setup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>webrtc</span>.<span style=color:#a6e22e>ConfigureFlexFEC03</span>(<span style=color:#a6e22e>fecPayloadType</span>, <span style=color:#a6e22e>mediaEngine</span>, <span style=color:#a6e22e>interceptorRegistry</span>)
</span></span></code></pre></div><p>Or setup codec and interceptor by hand:</p><ol><li>Register FlexFEC03 codec to MediaEngine</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>mediaEngine</span>.<span style=color:#a6e22e>RegisterCodec</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>webrtc</span>.<span style=color:#a6e22e>RTPCodecParameters</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>RTPCodecCapability</span>: <span style=color:#a6e22e>webrtc</span>.<span style=color:#a6e22e>RTPCodecCapability</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>MimeType</span>:     <span style=color:#a6e22e>webrtc</span>.<span style=color:#a6e22e>MimeTypeFlexFEC03</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>ClockRate</span>:    <span style=color:#ae81ff>90000</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Channels</span>:     <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>SDPFmtpLine</span>:  <span style=color:#e6db74>&#34;repair-window=10000000&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>RTCPFeedback</span>: <span style=color:#66d9ef>nil</span>,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PayloadType</span>: <span style=color:#ae81ff>118</span>, <span style=color:#75715e>// You can change this</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>webrtc</span>.<span style=color:#a6e22e>RTPCodecTypeVideo</span>,
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><ol start=2><li>Register FlexFEC interceptor</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>fecInterceptor</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flexfec</span>.<span style=color:#a6e22e>NewFecInterceptor</span>()
</span></span><span style=display:flex><span><span style=color:#75715e>// handle error...</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>interceptorRegistry</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>fecInterceptor</span>)
</span></span></code></pre></div><p>That&rsquo;s it! But with a few catches:</p><ol><li>The order of the FlexFEC interceptor in the chain of interceptors matters. It should be registered before <a href=https://github.com/pion/interceptor/blob/a1938a5c1ed53b7cd245ae019cd358ad8080cd5f/pkg/twcc/sender_interceptor.go>TWCC header extension interceptor</a> and <a href=https://github.com/pion/interceptor/blob/a1938a5c1ed53b7cd245ae019cd358ad8080cd5f/pkg/nack/responder_interceptor.go>NACK responder interceptor</a> if you are using these.</li><li>If you are using congestion controller, be aware of the bandwidth FEC is taking, you should set your encoder&rsquo;s bitrate to <code>cc_estimated_bandwidth - fec_bitrate</code>. By default, for every 5 media packets, 2 FEC packets will be produced, so expect roughly 40% bitrate overhead. You can tune FEC parameters to reduce or increase it.</li><li>Enabling FlexFEC encoding may introduce significant CPU/RAM overhead.</li><li>Current implementation does not protect media packet batches if they contain missing or reordered packets. So, it works best with senders that packetize media themselves.</li></ol><h3 id=configuring-flexfec-encoder-interceptor>Configuring FlexFEC Encoder Interceptor<a class=content-header-href href=#configuring-flexfec-encoder-interceptor><i class="fas fa-paperclip"></i></a></h3><p>You can customize FEC protection by tweaking <code>NumMediaPackets</code> and <code>NumFECPackets</code> using the interceptor&rsquo;s <a href=https://github.com/pion/interceptor/blob/a1938a5c1ed53b7cd245ae019cd358ad8080cd5f/pkg/flexfec/option.go>options</a>.</p><p>It will result in a protection profile which uses <code>NumFECPackets</code> FEC packets to protect each <code>NumMediaPackets</code> media packets. Interleaved protection will be used, which means that media packet <code>X</code> will be protected by FEC packet <code>(X mod NumFECPackets)</code>.</p><h3 id=verify-that-flexfec-is-enabled>Verify that FlexFEC is Enabled<a class=content-header-href href=#verify-that-flexfec-is-enabled><i class="fas fa-paperclip"></i></a></h3><ul><li>On sender side, which is within Pion, you can log the packets using the <a href=https://github.com/pion/interceptor/tree/a1938a5c1ed53b7cd245ae019cd358ad8080cd5f/pkg/packetdump>packetdump interceptor</a>.</li><li>On receiver side, for example, in Chromium, you can go to <code>chrome://webrtc-internals</code> and search for the stats graph of <code>fecBytesReceived</code>.</li></ul><h2 id=credits>Credits<a class=content-header-href href=#credits><i class="fas fa-paperclip"></i></a></h2><p>Huge thanks to everyone who contributed to this project: <a href=https://github.com/aalekseevx/>Aleksandr Alekseev</a>, <a href=https://github.com/3DRX/>Jingyang Kang</a>, <a href=https://github.com/JoeTurki>Joe Turki</a>, <a href=https://github.com/Sean-Der>Sean DuBois</a>, <a href=https://github.com/pougetat>Thomas Pouget-Abadie</a>.</p></div></section><footer class=footer><hr class=footer-hr><div class="content has-text-right"><p><a href=https://github.com/pion/website/blob/master/content/en/blog/fec-with-pion.md target=_blank>Edit this page</a></p></div></footer></main><script type=module>
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script></body></html>